{
  "id": "91k",
  "title": "Create ParallelRunner for multi-epic execution",
  "description": "Create ParallelRunner to orchestrate running multiple epics concurrently in separate worktrees.\n\n## Overview\n\nParallelRunner manages multiple Engine instances, each running in its own goroutine and worktree. It respects a max concurrency limit and aggregates results.\n\n## Files to Create\n\n### internal/parallel/runner.go\n\n```go\n// RunnerConfig configures parallel execution.\ntype RunnerConfig struct {\n    EpicIDs        []string       // Epics to run\n    MaxParallel    int            // Max concurrent epics (default: len(EpicIDs))\n    SharedBudget   *budget.Budget // Shared budget across all epics\n    WorktreeManager *worktree.Manager\n    MergeManager   *worktree.MergeManager\n}\n\n// EpicStatus represents the status of a single epic in parallel run.\ntype EpicStatus struct {\n    EpicID      string\n    Status      string    // \"pending\", \"running\", \"completed\", \"failed\", \"conflict\"\n    Worktree    *worktree.Worktree\n    Result      *engine.RunResult\n    Error       error\n    Conflict    *worktree.ConflictState\n    StartedAt   time.Time\n    CompletedAt time.Time\n}\n\n// ParallelResult is the aggregate result of all epics.\ntype ParallelResult struct {\n    Statuses    map[string]*EpicStatus\n    TotalCost   float64\n    TotalTokens int\n    Duration    time.Duration\n    AllSuccess  bool\n}\n\n// Runner orchestrates parallel epic execution.\ntype Runner struct {\n    config   RunnerConfig\n    statuses map[string]*EpicStatus\n    mu       sync.RWMutex\n}\n\n// NewRunner creates a parallel runner.\nfunc NewRunner(config RunnerConfig) *Runner\n\n// Run executes all epics, respecting MaxParallel limit.\n// Returns when all epics complete (or fail/conflict).\nfunc (r *Runner) Run(ctx context.Context) (*ParallelResult, error)\n\n// GetStatus returns current status of an epic.\nfunc (r *Runner) GetStatus(epicID string) *EpicStatus\n\n// GetAllStatuses returns status of all epics.\nfunc (r *Runner) GetAllStatuses() map[string]*EpicStatus\n```\n\n## Execution Flow\n\n```\nRunner.Run()\n    │\n    ├─→ Create semaphore with MaxParallel slots\n    ├─→ For each epic:\n    │   ├─→ Acquire semaphore slot\n    │   ├─→ Create worktree\n    │   ├─→ Start engine in goroutine\n    │   ├─→ On completion: merge, cleanup, release slot\n    │   └─→ Update EpicStatus\n    │\n    └─→ Wait for all goroutines\n        └─→ Return ParallelResult\n```\n\n## Implementation Notes\n\n- Use sync.WaitGroup for goroutine coordination\n- Use semaphore (buffered channel) for concurrency limit\n- Each epic gets its own Engine instance\n- Share Budget across all engines (thread-safe)\n- Status updates need mutex protection\n- Context cancellation should stop all running engines\n- On conflict: mark epic as \"conflict\", don't block others\n\n### Callbacks for TUI\n\n```go\ntype RunnerCallbacks struct {\n    OnEpicStart    func(epicID string)\n    OnEpicComplete func(epicID string, result *engine.RunResult)\n    OnEpicFailed   func(epicID string, err error)\n    OnEpicConflict func(epicID string, conflict *worktree.ConflictState)\n    OnStatusChange func(epicID string, status string)\n}\n```\n\n### internal/parallel/runner_test.go\n- Test single epic (degenerate case)\n- Test multiple epics run concurrently\n- Test MaxParallel limit respected\n- Test shared budget across epics\n- Test context cancellation stops all\n- Test conflict handling doesn't block other epics",
  "status": "open",
  "priority": 1,
  "type": "task",
  "owner": "peter@engelbrecht.dk",
  "blocked_by": [
    "xvz"
  ],
  "parent": "8my",
  "acceptance_criteria": "1. ParallelRunner can run multiple epics concurrently\n2. MaxParallel limit is respected (semaphore-based)\n3. Each epic runs in its own worktree\n4. Shared budget tracks cost across all epics\n5. EpicStatus accurately reflects each epic's state\n6. Context cancellation stops all running engines\n7. Conflict in one epic doesn't block others\n8. Callbacks fire appropriately for TUI integration\n9. All tests pass",
  "created_by": "peter@engelbrecht.dk",
  "created_at": "2026-01-12T10:02:20.543835Z",
  "updated_at": "2026-01-12T10:02:20.543835Z"
}