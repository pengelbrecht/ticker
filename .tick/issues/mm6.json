{
  "id": "mm6",
  "title": "Add conflict handling workflow",
  "description": "Implement the workflow for handling merge conflicts: pause epic, notify user, wait for resolution.\n\n## Overview\n\nWhen a merge conflict occurs, the epic should pause and the user needs to manually resolve the conflict. After resolution, they can resume the epic (or it auto-resumes if running in parallel with other epics).\n\n## Files to Create/Modify\n\n### internal/worktree/conflict.go\n\n```go\n// ConflictState tracks an unresolved merge conflict.\ntype ConflictState struct {\n    EpicID        string\n    Branch        string\n    Conflicts     []string  // List of conflicting files\n    WorktreePath  string    // Worktree that completed\n    DetectedAt    time.Time\n}\n\n// ConflictHandler manages conflict lifecycle.\ntype ConflictHandler struct {\n    repoRoot string\n    merge    *MergeManager\n}\n\n// HandleConflict is called when merge fails due to conflict.\n// Aborts the merge (leaves worktree intact for reference).\n// Returns ConflictState for TUI display.\nfunc (h *ConflictHandler) HandleConflict(wt *Worktree, conflicts []string) *ConflictState\n\n// CheckResolved checks if a conflict has been manually resolved.\n// User resolves by: checking out main, manually merging, committing.\n// Returns true if the worktree branch is now merged into main.\nfunc (h *ConflictHandler) CheckResolved(epicID string) bool\n\n// GetActiveConflicts returns all unresolved conflicts.\nfunc (h *ConflictHandler) GetActiveConflicts() []*ConflictState\n```\n\n## Conflict Workflow\n\n```\nEpic completes in worktree\n    │\n    └─→ Attempt merge to main\n        │\n        ├─→ Success → cleanup worktree, continue\n        │\n        └─→ Conflict detected\n            │\n            ├─→ Abort merge (git merge --abort)\n            ├─→ Keep worktree (user may need to inspect)\n            ├─→ Store ConflictState\n            ├─→ Notify TUI (ConflictMsg)\n            │\n            └─→ User manually resolves:\n                1. cd to main repo\n                2. git checkout main\n                3. git merge ticker/\u003cepic-id\u003e\n                4. Resolve conflicts\n                5. git commit\n                │\n                └─→ Ticker detects resolution\n                    ├─→ Cleanup worktree\n                    └─→ Update TUI\n```\n\n## Integration Points\n\n- Engine calls ConflictHandler.HandleConflict() on merge failure\n- Parallel runner checks GetActiveConflicts() periodically\n- TUI receives ConflictMsg for display\n- ConflictState persisted so survives ticker restart?\n\n### internal/worktree/conflict_test.go\n- Test HandleConflict aborts merge and stores state\n- Test CheckResolved detects when branch is merged\n- Test GetActiveConflicts returns all pending\n- Test conflict state lifecycle",
  "status": "closed",
  "priority": 2,
  "type": "task",
  "owner": "peter@engelbrecht.dk",
  "blocked_by": [
    "gom"
  ],
  "parent": "8my",
  "acceptance_criteria": "1. HandleConflict aborts the git merge safely\n2. HandleConflict preserves worktree for user inspection  \n3. ConflictState captures all relevant info (files, paths, timing)\n4. CheckResolved detects when user has manually merged\n5. GetActiveConflicts tracks all unresolved conflicts\n6. Conflict workflow integrates with engine completion\n7. All tests pass",
  "created_by": "peter@engelbrecht.dk",
  "created_at": "2026-01-12T10:01:57.747619Z",
  "updated_at": "2026-01-12T22:11:33.821198114Z",
  "closed_at": "2026-01-12T22:11:33.821198114Z",
  "closed_reason": "Implemented ConflictHandler in internal/worktree/conflict.go with: (1) ConflictState struct tracking epic, branch, conflicts, worktree path, and detection time, (2) HandleConflict() aborts merge and stores state, (3) CheckResolved() detects manual merge via git merge-base --is-ancestor, (4) GetActiveConflicts/GetConflict/HasConflict/ClearConflict for state management, (5) ConflictInfo() for human-readable summary. 18 tests in conflict_test.go covering all functionality."
}