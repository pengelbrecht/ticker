{
  "id": "t99",
  "title": "Phase 3: Verification System",
  "description": "Add automated verification to ensure tasks are actually complete before the engine moves on.\n\n## Design Decision: GitVerifier Only\n\nAfter analysis, we're implementing **GitVerifier only**:\n\n- **Agent already tests** - The prompt instructs agents to \"Run tests - Ensure all existing tests pass\" (prompt.go:139)\n- **Avoid double work** - Running test suites twice (agent + verification) wastes time, especially for slow suites\n- **GitVerifier catches what agent can't** - Uncommitted changes are the one thing the agent can't easily self-verify\n\nRejected verifiers (may reconsider later):\n- TestVerifier - redundant with agent's own testing\n- BuildVerifier - agent sees build errors when testing\n- ScriptVerifier - custom needs can be added if users request\n\n## Overview\n\nVerification runs when the agent closes a task. If the working tree has uncommitted changes, the task is reopened and failure details are added as an epic note for the next iteration.\n\n## Components\n\n1. **Verifier interface** - Common contract (minimal, for GitVerifier)\n2. **Config system** - `.ticker/config.json` with enabled flag\n3. **GitVerifier** - Checks for uncommitted changes via `git status --porcelain`\n4. **VerificationRunner** - Orchestrates verifier execution\n5. **Engine integration** - Hooks verification into iteration loop on task close\n6. **CLI flags** - --skip-verify, --verify-only\n7. **TUI status** - Show verification progress/results\n\n## Config Example\n\n```json\n{\n  \"verification\": {\n    \"enabled\": true\n  }\n}\n```\n\n## Exit Criteria\n\n- GitVerifier runs automatically after agent closes task\n- Uncommitted changes cause task to reopen with note\n- --skip-verify flag works\n- --verify-only flag works (debug mode)\n- TUI shows verification status",
  "notes": "2026-01-12 10:07 - Task 194 complete: Created internal/verify package with Verifier interface and Result/Results types. The interface is minimal by design - just Name() and Verify(ctx, taskID, agentOutput). Results has Summary() for human-readable output and FailedResults() for filtering. Next tasks can implement GitVerifier using this interface. No circular deps - verify package only uses stdlib.\n2026-01-12 10:08 - Task 3nt complete: Added Config with pointer-based Enabled field so nil defaults to true (verification enabled by default). LoadConfig returns nil config (not error) when .ticker/config.json is missing - this lets callers use IsEnabled() on nil config and get the default behavior. TickerConfig is the root struct that wraps verification config. All tests pass including edge cases for missing files and malformed JSON.\n2026-01-12 10:10 - Task mph complete: GitVerifier implemented with constructor that checks for .git directory (returns nil if not git repo), Name() returning 'git', and Verify() using 'git status --porcelain'. Empty output = pass, non-empty = fail with file list in output. Tests use temp git repos with initial commits for isolation. Next task can implement VerificationRunner to orchestrate verifier execution.\n2026-01-12 10:12 - Task kvd complete: VerificationRunner implemented in internal/verify/runner.go. Runner.Run() takes verifiers, runs them sequentially, and returns aggregated *Results. The dir field is stored but currently unused - future verifiers could use it. Tests include mock verifier with configurable delay for cancellation testing. Next task should integrate Runner into the engine to run verification after task close.",
  "status": "open",
  "priority": 1,
  "type": "epic",
  "owner": "peter@engelbrecht.dk",
  "created_by": "peter@engelbrecht.dk",
  "created_at": "2026-01-12T08:59:15.125957Z",
  "updated_at": "2026-01-12T09:12:17.600455Z"
}