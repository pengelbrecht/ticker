# Epic Context: Pre-computed Context Documents

> Reduce redundant context-gathering across tasks by generating a shared context document per epic.

## Problem

Each task under an epic spends significant time and tokens gathering context:
- Reading and understanding relevant code files
- Finding architectural patterns and conventions
- Looking up external documentation
- Understanding the codebase structure

This is redundant—tasks in the same epic typically need similar context. A "user authentication" epic means every task needs to understand auth patterns, relevant files, and API conventions.

**Current cost model:**
```
Task 1: ~5k tokens gathering context + work
Task 2: ~5k tokens gathering context + work  (mostly same context)
Task 3: ~5k tokens gathering context + work  (mostly same context)
...
Total: N × 5k tokens just for context
```

**Proposed cost model:**
```
Epic init: ~8k tokens generating rich context document (once)
Task 1: context doc injected + work
Task 2: context doc injected + work
Task 3: context doc injected + work
...
Total: 8k + (N × ~1k for doc injection)
```

For epics with 5+ tasks, this is a significant win.

## Solution

Generate a **context document** when an epic is first worked on. This document is:
- Generated by Claude analyzing the epic and codebase
- Stored outside `.tick/` to keep issues compact
- Injected into every task's prompt via `--append-system-prompt`
- Optionally refreshed if it becomes stale

## Storage

```
.ticker/
├── config.json
├── checkpoints/
├── runs/
└── context/
    ├── h8d.md          # Context for epic h8d
    ├── fbv.md          # Context for epic fbv
    └── 5b8.md          # Context for epic 5b8
```

**Why `.ticker/context/`:**
- Keeps `.tick/issues/` compact (issue data only)
- Lives alongside other ticker runtime state
- Easy to regenerate if deleted
- Can be gitignored (runtime artifact) or tracked (team context sharing)

## Context Document Structure

```markdown
# Epic Context: [h8d] Parallel test execution

Generated: 2025-01-16T10:30:00Z
Epic: h8d - Parallel test execution

## Relevant Code

### Core Files
- `internal/engine/engine.go` - Main orchestration loop, runs iterations
- `internal/agent/claude.go` - Claude Code agent implementation
- `internal/tui/model.go` - Bubble Tea TUI state management

### Key Types
- `Engine` (engine.go:45) - Orchestrates the Ralph loop
- `Agent` interface (agent.go:12) - Agent abstraction
- `Model` (model.go:23) - TUI state

### Patterns in Use
- Bubble Tea for TUI (Model/Update/View pattern)
- Context cancellation for graceful shutdown
- Streaming output via channels

## Architecture Notes

- Engine runs in goroutine, sends messages to TUI via tea.Cmd
- Agent output streams through `onOutputStream` callback
- Checkpoints saved every N iterations to `.ticker/checkpoints/`

## External References

- Bubble Tea docs: https://github.com/charmbracelet/bubbletea
- Go concurrency patterns for worker pools

## Testing Patterns

- Table-driven tests in `*_test.go` files
- Mock agent for engine tests
- Integration tests use real `tk` CLI

## Conventions

- Error wrapping with `fmt.Errorf("context: %w", err)`
- Logging via structured logger
- Config in `.ticker/config.json`
```

## Generation Process

### When to Generate

1. **First task of epic** - When `tk next <epic>` returns a task and no context exists
2. **Manual refresh** - `ticker context <epic-id> --refresh`
3. **Auto-refresh** - If context is older than N days (configurable)

### Generation Prompt

The context is generated by running Claude with a specialized prompt:

```markdown
# Generate Epic Context

You are preparing context for an AI coding agent that will work on tasks in this epic.

## Epic
**[{{.EpicID}}] {{.EpicTitle}}**

{{.EpicDescription}}

## Tasks in this Epic
{{range .Tasks}}
- [{{.ID}}] {{.Title}}
{{end}}

## Instructions

Analyze the codebase and generate a context document that will help complete these tasks.

Include:

1. **Relevant Code** - Files and functions that tasks will likely need to read or modify
   - List file paths with brief descriptions
   - Note key types, interfaces, and functions
   - Identify patterns and conventions used

2. **Architecture Notes** - How the relevant parts of the system work together
   - Data flow
   - Key abstractions
   - Integration points

3. **External References** - Documentation for libraries/frameworks in use
   - Don't fetch full docs, just note what's relevant
   - Include links if helpful

4. **Testing Patterns** - How tests are structured in this area
   - Test file locations
   - Mocking patterns
   - Coverage expectations

5. **Conventions** - Code style and patterns to follow
   - Error handling approach
   - Logging conventions
   - Naming patterns

## Constraints

- Keep the document under 4000 tokens
- Focus on what's RELEVANT to the epic's tasks
- Summarize, don't copy entire files
- Be specific (file:line references) not vague

Output the context document in markdown format.
```

### Generation Flow

```
┌──────────────────────────────────────────────────────────────┐
│                    CONTEXT GENERATION                        │
│                                                              │
│  1. Check for existing context                               │
│     └─ .ticker/context/<epic-id>.md exists? → skip           │
│                                                              │
│  2. Gather inputs                                            │
│     ├─ Epic title, description                               │
│     └─ Task list (titles only, for scope)                    │
│                                                              │
│  3. Run context generation agent                             │
│     ├─ Prompt: "Generate epic context for..."                │
│     ├─ Agent explores codebase (Glob, Grep, Read)            │
│     └─ Agent outputs structured markdown                     │
│                                                              │
│  4. Store context                                            │
│     └─ Write to .ticker/context/<epic-id>.md                 │
│                                                              │
│  5. Proceed to first task                                    │
│     └─ Context now available for injection                   │
└──────────────────────────────────────────────────────────────┘
```

## Integration with Engine

### IterationContext Changes

```go
type IterationContext struct {
    Iteration     int
    Epic          *ticks.Epic
    Task          *ticks.Task
    EpicNotes     []string
    HumanFeedback []ticks.Note

    // NEW: Pre-computed epic context
    EpicContext   string  // Contents of .ticker/context/<epic-id>.md
}
```

### Prompt Template Changes

Add context section before the task:

```go
const promptTemplate = `# Iteration {{.Iteration}}

{{if .EpicContext}}
## Epic Context

The following context was generated for this epic. Use it to understand the codebase.

{{.EpicContext}}
{{end}}

{{if .EpicNotes}}
## Epic Notes
...
{{end}}
...
```

### Engine Flow Changes

```go
func (e *Engine) Run(ctx context.Context, cfg RunConfig) error {
    // NEW: Ensure epic context exists
    if err := e.ensureEpicContext(ctx, cfg.EpicID); err != nil {
        return fmt.Errorf("generating epic context: %w", err)
    }

    // Load context for injection
    epicContext, _ := e.loadEpicContext(cfg.EpicID)

    for {
        task, err := e.ticks.Next(cfg.EpicID)
        if err != nil { ... }

        iterCtx := IterationContext{
            Epic:        epic,
            Task:        task,
            EpicContext: epicContext,  // NEW
            ...
        }

        prompt := e.promptBuilder.Build(iterCtx)
        ...
    }
}
```

## CLI Commands

```bash
# Generate context for an epic (usually automatic)
ticker context <epic-id>

# Force regeneration
ticker context <epic-id> --refresh

# View existing context
ticker context <epic-id> --show

# Delete context (will regenerate on next run)
ticker context <epic-id> --delete
```

## Configuration

In `.ticker/config.json`:

```json
{
  "context": {
    "enabled": true,
    "max_tokens": 4000,
    "auto_refresh_days": 7,
    "include_web_research": true
  }
}
```

| Option | Default | Description |
|--------|---------|-------------|
| `enabled` | `true` | Enable epic context generation |
| `max_tokens` | `4000` | Target size for context document |
| `auto_refresh_days` | `7` | Regenerate if older than N days (0 = never) |
| `include_web_research` | `true` | Allow web fetches for external docs |

## Context Staleness

As tasks complete, the codebase changes. The context document may become stale.

### Detection

- Track file modification times vs context generation time
- If >50% of referenced files changed, mark as stale
- If context is older than `auto_refresh_days`, mark as stale

### Refresh Strategies

1. **Manual** - User runs `ticker context <epic> --refresh`
2. **Auto on threshold** - Regenerate if staleness score > threshold
3. **Append-only** - Add "Updates since generation" section instead of full regen

### Recommended Approach

Start simple: regenerate on manual request only. Add auto-refresh later if needed.

## Token Budget

Context generation has its own budget, separate from task iterations:

```go
type ContextGenerationConfig struct {
    MaxTokens   int           // Max tokens for generation (default: 50k)
    MaxCost     float64       // Max cost (default: $1.00)
    Timeout     time.Duration // Max time (default: 5min)
}
```

Context generation uses cheaper/faster settings since it's exploratory:
- Could use `--model sonnet` even if tasks use opus
- Simpler prompt, no tool restrictions

## Open Questions

1. **Incremental updates** - Should context be updated after each task, or stay static?
2. **Per-task context** - Should tasks get task-specific context in addition to epic context?
3. **Context inheritance** - If epic has sub-epics, should context cascade?
4. **Failure handling** - What if context generation fails? Proceed without context?
5. **Size limits** - How to handle epics that need more than `max_tokens` of context?

## Implementation Plan

### Phase 1: Basic Context Generation
- [ ] Add `.ticker/context/` directory structure
- [ ] Implement `ensureEpicContext()` in engine
- [ ] Add `EpicContext` field to `IterationContext`
- [ ] Update prompt template to include context
- [ ] Add `ticker context` CLI command

### Phase 2: Configuration & Polish
- [ ] Add config options to `.ticker/config.json`
- [ ] Implement `--refresh` and `--show` flags
- [ ] Add context generation budget tracking
- [ ] TUI indicator for context status

### Phase 3: Staleness & Refresh (Future)
- [ ] Track referenced files
- [ ] Detect staleness
- [ ] Auto-refresh logic

## Alternatives Considered

### 1. Persistent Agent Memory
Let the agent build up context in its own memory/conversation.

**Rejected:** Claude Code doesn't persist context between invocations. Each `claude` CLI call is fresh.

### 2. CLAUDE.md Injection
Put epic context in the project's CLAUDE.md file.

**Rejected:** CLAUDE.md is for project-wide instructions, not epic-specific context. Would require modifying tracked file.

### 3. System Prompt via Flag
Use `claude --system-prompt-file` to inject context.

**Considered:** This is viable but `--append-system-prompt` is more appropriate since it adds to rather than replaces the system prompt.

### 4. Task Description Expansion
Expand each task's description to include all context.

**Rejected:** Would bloat `.tick/issues/` and duplicate context across tasks.

## References

- [Claude Code CLI flags](https://docs.anthropic.com/en/docs/claude-code) - `--append-system-prompt`
- [SPEC.md](../SPEC.md) - Ticker specification
- [prompt.go](../internal/engine/prompt.go) - Current prompt building
